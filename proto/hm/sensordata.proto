syntax = "proto3";
option go_package=".;sensordata";

message ImuData {
    message AccelerometerData {
        double x = 1;
        double y = 2;
        double z = 3;
    }
    message GyroscopeData {
        double x = 1;
        double y = 2;
        double z = 3;
    }

    string system_time = 1;
    AccelerometerData accelerometer = 2;
    GyroscopeData gyroscope = 3;
    double temperature = 4;
    string time = 5; // is this needed?
}

message MagnetometerData {
    string system_time = 1;
    double x = 2;
    double y = 3;
    double z = 4;
}



// type Data struct {
// 	Ttff               int64       `json:"ttff"`
// 	SystemTime         time.Time   `json:"systemtime"`
// 	ActualSystemTime   time.Time   `json:"actual_systemtime"`
// 	Timestamp          time.Time   `json:"timestamp"`
// 	Fix                string      `json:"fix"`
// 	Latitude           float64     `json:"latitude"`
// 	UnfilteredLatitude float64     `json:"unfiltered_latitude"`
// 	Longitude          float64     `json:"longitude"`
// 	UnfilteredLongitude float64    `json:"unfiltered_longitude"`
// 	Altitude           float64     `json:"height"`
// 	Heading            float64     `json:"heading"`
// 	Speed              float64     `json:"speed"`
// 	Dop                *Dop        `json:"dop"`
// 	Satellites         *Satellites `json:"satellites"`
// 	Sep                float64     `json:"sep"` // Estimated Spherical (3D) Position Error in meters. Guessed to be 95% confidence, but many GNSS receivers do not specify, so certainty unknown.
// 	Eph                float64     `json:"eph"` // Estimated horizontal Position (2D) Error in meters. Also known as Estimated Position Error (epe). Certainty unknown.
// 	RF                 *RF         `json:"rf,omitempty"`
// 	SpeedAccuracy      float64     `json:"speed_accuracy"`
// 	HeadingAccuracy    float64     `json:"heading_accuracy"`
// 	TimeResolved	   int         `json:"time_resolved"`
// 	HorizontalAccuracy float64     `json:"horizontal_accuracy"`
// 	VerticalAccuracy   float64     `json:"vertical_accuracy"`

// 	startTime       time.Time
// 	GGA             string         `json:"gga"`
// 	RxmMeasx        *ubx.RxmMeasx  `json:"rxm_measx"`
// 	SecEcsign       *ubx.SecEcsign `json:"sec_ecsign"`
// 	SecEcsignBuffer string         `json:"sec_ecsign_buffer"`
// 	//todo: add optional signature and hash struct genereated from UBX-SEC-ECSIGN messages by the decoder
// }

// type Dop struct {
// 	GDop float64 `json:"gdop"`
// 	HDop float64 `json:"hdop"`
// 	PDop float64 `json:"pdop"`
// 	TDop float64 `json:"tdop"`
// 	VDop float64 `json:"vdop"`
// 	XDop float64 `json:"xdop"`
// 	YDop float64 `json:"ydop"`
// }

// type Satellites struct {
// 	Seen int `json:"seen"`
// 	Used int `json:"used"`
// }

// type RF struct {
// 	JammingState string `json:"jamming_state"`
// 	AntStatus    string `json:"ant_status"`
// 	AntPower     string `json:"ant_power"`
// 	PostStatus   uint32 `json:"post_status"`
// 	NoisePerMS   uint16 `json:"noise_per_ms"`
// 	AgcCnt       uint16 `json:"agc_cnt"`
// 	JamInd       uint8  `json:"jam_ind"`
// 	OfsI         int8   `json:"ofs_i"`
// 	MagI         byte   `json:"mag_i"`
// 	OfsQ         int8   `json:"ofs_q"`
// 	MagQ         byte   `json:"mag_q"`
// }


// type RxmMeasx struct {
//     Version         byte              `json:"version"`
//     Reserved1       [3]byte           `json:"reserved_1"`
//     GpsTOW_ms       uint32            `json:"gps_tow_ms"`
//     GloTOW_ms       uint32            `json:"glo_tow_ms"`
//     BdsTOW_ms       uint32            `json:"bds_tow_ms"`
//     Reserved2       [4]byte           `json:"reserved_2"`
//     QzssTOW_ms      uint32            `json:"qzss_tow_ms"`
//     GpsTOWacc_msl4  uint16            `json:"gps_to_wacc_msl4"`
//     GloTOWacc_msl4  uint16            `json:"glo_to_wacc_msl4"`
//     BdsTOWacc_msl4  uint16            `json:"bds_to_wacc_msl4"`
//     Reserved3       [2]byte           `json:"reserved_3"`
//     QzssTOWacc_msl4 uint16            `json:"qzss_to_wacc_msl4"`
//     NumSV           byte              `len:"SV" json:"num_sv"` // Number of satellites in repeated block
//     Flags           RxmMeasxFlags     `json:"flags"`
//     Reserved4       [8]byte           `json:"reserved_4"`
//     SV              []*RxmMeasxSVType `json:"sv_list"`
// }


// type RxmMeasxSVType struct {
//     GnssId          byte    `json:"gnss_id"`
//     SvId            byte    `json:"sv_id"`
//     CNo             byte    `json:"c_no"`
//     MpathIndic      byte    `json:"mpath_indic"`
//     DopplerMS_m_s   int32   `json:"doppler_ms_m_s"`
//     DopplerHz_hz    int32   `json:"doppler_hz_hz"`
//     WholeChips      uint16  `json:"whole_chips"`
//     FracChips       uint16  `json:"frac_chips"`
//     CodePhase_msl21 uint32  `json:"code_phase_msl_21"`
//     IntCodePhase_ms byte    `json:"int_code_phase_ms"`
//     PseuRangeRMSErr byte    `json:"pseu_range_rms_err"`
//     Reserved5       [2]byte `json:"reserved_5"`
// }

// type SecEcsign struct {
// 	Version        uint8
// 	Reserved0      uint8
// 	MsgNum         uint16
// 	FinalHash      [32]byte
// 	SessionId      [24]byte
// 	EcdsaSignature [48]byte
// }

message GnssData {

    message Dop {
        double gdop = 1;
        double hdop = 2;
        double pdop = 3;
        double tdop = 4;
        double vdop = 5;
        double xdop = 6;
        double ydop = 7;
    }

    message Satellites {
        int64 seen = 1;
        int64 used = 2;
    }

    message RF {
        string jamming_state = 1;
        string ant_status = 2;
        string ant_power = 3;
        uint32 post_status = 4;
        uint32 noise_per_ms = 5;
        uint32 agc_cnt = 6;
        uint32 jam_ind = 7;
        int32 ofs_i = 8;
        int32 mag_i = 9;
        int32 ofs_q = 10;
        int32 mag_q = 11;
    }

    message RxmMeasxSVType {
        int32 gnss_id = 1;
        int32 sv_id = 2;
        int32 c_no = 3;
        int32 mpath_indic = 4;
        int32 doppler_ms_m_s = 5;
        int32 doppler_hz_hz = 6;
        uint32 whole_chips = 7;
        uint32 frac_chips = 8;
        int32 code_phase_msl_21 = 9;
        int32 int_code_phase_ms = 10;
        int32 pseu_range_rms_err = 11;
        bytes reserved5 = 12;
    }

    message RxmMeasx {
        int32 version = 1;
        bytes reserved1 = 2;
        uint32 gps_tow_ms = 3;
        uint32 glo_tow_ms = 4;
        uint32 bds_tow_ms = 5;
        bytes reserved2 = 6;
        uint32 qzss_tow_ms = 7;
        uint32 gps_tow_acc_msl4 = 8;
        uint32 glo_tow_acc_msl4 = 9;
        uint32 bds_tow_acc_msl4 = 10;
        bytes reserved3 = 11;
        uint32 qzss_tow_acc_msl4 = 12;
        int32 num_sv = 13;
        int32 flags = 14;
        bytes reserved4 = 15;
        repeated RxmMeasxSVType sv = 16;
    }

    message UbxSecEcsign {
        uint32 version = 1;
        bytes reserved0 = 2;
        uint32 msg_num = 3;
        bytes final_hash = 4;
        bytes session_id = 5;
        bytes ecdsa_signature = 6;
    }

    int64 ttff = 1;
    string system_time = 2;
    string actual_system_time = 3;
    string timestamp = 4;
    string fix = 5;
    double latitude = 6;
    double unfiltered_latitude = 7;
    double longitude = 8;
    double unfiltered_longitude = 9;
    double altitude = 10;
    double heading = 11;
    double speed = 12;
    Dop dop = 13;
    Satellites satellites = 14;
    double sep = 15;
    double eph = 16;
    RF rf = 17;
    double speed_accuracy = 18;
    double heading_accuracy = 19;
    int32 time_resolved = 20;
    double horizontal_accuracy = 21;
    double vertical_accuracy = 22;
    string gga = 23;
    RxmMeasx rxm_measx = 24;
    UbxSecEcsign sec_ecsign = 25;
    string sec_ecsign_buffer = 26;
}